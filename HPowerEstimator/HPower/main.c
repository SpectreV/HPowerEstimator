#include <stdio.h>
#include <time.h>

#include "power.h"
#include "input.h"
#include "blif.h"
#include "route.h"

float grid_logic_tile_area = 0;
float ipin_mux_trans_size = 0;

/* t-vpack globals begin  */
int num_logical_nets = 0, num_logical_blocks = 0, num_saved_logical_blocks = 0,
		num_saved_logical_nets = 0, num_subckts = 0;
int num_p_inputs = 0, num_p_outputs = 0, num_luts = 0, num_latches = 0;
struct s_net *vpack_net = NULL, *saved_logical_nets = NULL;
struct s_logical_block *logical_block = NULL, *saved_logical_blocks = NULL;
struct s_subckt *subckt = NULL;
char *blif_circuit_name = NULL;
/* t-vpack globals end  */

/******** Netlist to be mapped stuff ********/

int num_nets = 0;
struct s_net *clb_net = NULL;

int num_blocks = 0;
struct s_block *block = NULL;

int num_ff = 0;
int num_const_gen = 0;

int *clb_to_vpack_net_mapping = NULL; /* [0..num_clb_nets - 1] */
int *vpack_to_clb_net_mapping = NULL; /* [0..num_vpack_nets - 1] */

/* This identifies the t_type_ptr of an IO block */
int num_types = 0;
struct s_type_descriptor *type_descriptors = NULL;

t_type_ptr IO_TYPE = NULL;
t_type_ptr EMPTY_TYPE = NULL;
t_type_ptr FILL_TYPE = NULL;

/******** Physical architecture stuff ********/

int nx = 0;
int ny = 0;

/* TRUE if this is a global clb pin -- an input pin to which the netlist can *
 * connect global signals, but which does not connect into the normal        *
 * routing via muxes etc.  Marking pins like this (only clocks in my work)   *
 * stops them from screwing up the input switch pattern in the rr_graph      *
 * generator and from creating extra switches that the area model would      *
 * count.                                                                    */

int *chan_width_x = NULL; /* [0..ny] */
int *chan_width_y = NULL; /* [0..nx] */

struct s_grid_tile **grid = NULL; /* [0..(nx+1)][0..(ny+1)] Physical block list */

/******** Structures defining the routing ********/

/* Linked list start pointers.  Define the routing. */
struct s_trace **trace_head = NULL; /* [0..(num_nets-1)] */
struct s_trace **trace_tail = NULL; /* [0..(num_nets-1)] */

/******** Structures defining the FPGA routing architecture ********/

int num_rr_nodes = 0;
t_rr_node *rr_node = NULL; /* [0..(num_rr_nodes-1)] */
t_ivec ***rr_node_indices = NULL;

int num_rr_indexed_data = 0;
t_rr_indexed_data *rr_indexed_data = NULL; /* [0..(num_rr_indexed_data-1)] */

/* Gives the rr_node indices of net terminals. */

int **net_rr_terminals = NULL; /* [0..num_nets-1][0..num_pins-1] */

/* Gives information about all the switch types                      *
 * (part of routing architecture, but loaded in read_arch.c          */

struct s_switch_inf *switch_inf = NULL; /* [0..(det_routing_arch.num_switch-1)] */

/* Stores the SOURCE and SINK nodes of all CLBs (not valid for pads).     */

int **rr_blk_source = NULL; /* [0..(num_blocks-1)][0..(num_class-1)] */

/* primiary inputs removed from circuit */
struct s_linked_vptr *circuit_p_io_removed = NULL;

/********** Structures representing timing graph information */
t_tnode *tnode = NULL; /* [0..num_tnodes - 1] */
int num_tnodes = 0; /* Number of nodes (pins) in the timing graph */
float pb_max_internal_delay = UNDEFINED; /* biggest internal delay of physical block */
const t_pb_type *pbtype_max_internal_delay = NULL; /* physical block type with highest internal delay */

t_model *user_models, *library_models;
t_arch Arch;
int TimingEnabled = 1;
struct s_det_routing_arch *RoutingArch = NULL;
struct s_timing_inf *Timing = NULL;

/*float T_critical_path = 4.40561e-09;*/
float T_critical_path = -1;
int fixed_chan_width = 0;

typedef struct s_file_names {
	char *archFile;
	char *blifFile;
	char *actFile;
	char *netFile;
	char *placeFile;
	char *routeFile;
	char *libFile;
	char *circuitName;
} t_file_names;

static void InitArch(t_arch Arch);
static void print_usage();
static void read_options(int argc, char **argv, t_file_names *file_names);

int main(int argc, char **argv) {

	t_file_names file_names;

	/*  This is the flow of Hierarchical Power Estimator
	 *
	 * 	1. Reading in the architecture file and routing channel width,
	 * 	   building up exactly same architecture and routing resource graph
	 * 	   of the implemented circuit in VPR
	 * 	2. Reading in the power library provided by the user
	 * 	3. Reading in the blif file and the corresponding
	 * 	   activity file generated by ACE2,
	 * 	4. Reading in the netlist in there is one (Optional)
	 * 	5. Reading in physical synthesis information, placement and routing, to be specific*/
	printf("Thank you for using HPowerEstimator\n");

	if (argc < 4 || 0 != (argc - 4) % 2) {
		print_usage();
		exit(1);
	}
	read_options(argc, argv, &file_names);

	build_arch(file_names.archFile, TimingEnabled, &Arch);

	build_blif(file_names.blifFile, 1, user_models, library_models, file_names.actFile);

	printf("Blif file loaded successfully!\n"
			"logic nets: %d \n"
			"logic blocks: %d \n"
			"logic_pi: %d \n"
			"logic_po: %d \n"
			"luts: %d \n"
			"latches: %d \n", num_logical_nets, num_logical_blocks,
			num_p_inputs, num_p_outputs, num_luts, num_latches);

	read_netlist(file_names.netFile, &Arch, &num_blocks, &block, &num_nets, &clb_net);

	build_place(file_names.placeFile, file_names.netFile, file_names.archFile, num_blocks, block);

	Arch.clb_grid.W = nx;
	Arch.clb_grid.H = ny;
	Arch.clb_grid.IsAuto = FALSE;

	InitArch(Arch);

	sync_grid_to_blocks(num_blocks, block, nx, ny, grid);

	read_trace_file(file_names.routeFile);

	power_estimation(file_names.libFile);

	return 0;

}

static void read_options(int argc, char **argv, t_file_names *file_names) {

	file_names->archFile = NULL;
	file_names->circuitName = NULL;
	file_names->libFile = NULL;
	file_names->actFile = NULL;
	file_names->blifFile = NULL;
	file_names->netFile = NULL;
	file_names->placeFile = NULL;
	file_names->routeFile = NULL;

	int arg_idx, len;
	int crit_flag;
	int chan_flag;

	/* Argument list starts from 1*/
	arg_idx = 1;

	while (arg_idx < argc) {
		if (strncmp("--", argv[arg_idx], 2) == 0)
			argv[arg_idx] += 2;
		else if (strncmp("-", argv[arg_idx], 1) == 0)
			argv[arg_idx] += 1;
		else if (NULL == file_names->archFile) {
			file_names->archFile = my_strdup(argv[arg_idx]);
			arg_idx++;
			continue;
		} else if (NULL == file_names->circuitName) {
			file_names->circuitName = my_strdup(argv[arg_idx]);
			arg_idx++;
			continue;
		} else if (NULL == file_names->libFile) {
			file_names->libFile = my_strdup(argv[arg_idx]);
			arg_idx++;
			continue;
		}

		if (strcmp(argv[arg_idx], "blif_file") == 0) {
			arg_idx++;
			file_names->blifFile = my_strdup(argv[arg_idx]);
			arg_idx++;
		} else if (strcmp(argv[arg_idx], "act_file") == 0) {
			arg_idx++;
			file_names->actFile = my_strdup(argv[arg_idx]);
			arg_idx++;
		} else if (strcmp(argv[arg_idx], "net_file") == 0) {
			arg_idx++;
			file_names->netFile = my_strdup(argv[arg_idx]);
			arg_idx++;
		} else if (strcmp(argv[arg_idx], "place_file") == 0) {
			arg_idx++;
			file_names->placeFile = my_strdup(argv[arg_idx]);
			arg_idx++;
		} else if (strcmp(argv[arg_idx], "route_file") == 0) {
			arg_idx++;
			file_names->routeFile = my_strdup(argv[arg_idx]);
			arg_idx++;
		}
	}

	len = strlen(file_names->circuitName);
	if (file_names->blifFile == NULL) {
		file_names->blifFile = (char *) malloc(sizeof(char) * (len + 6)); /*"circuitname.blif\0"*/
		sprintf(file_names->blifFile, "%s.blif", file_names->circuitName);
	}
	if (file_names->actFile == NULL) {
		file_names->actFile = (char *) malloc(sizeof(char) * (len + 5)); /*"circuitname.act\0"*/
		sprintf(file_names->actFile, "%s.act", file_names->circuitName);
	}
	if (file_names->netFile == NULL) {
		file_names->netFile = (char *) malloc(sizeof(char) * (len + 5)); /*"circuitname.net\0"*/
		sprintf(file_names->netFile, "%s.net", file_names->circuitName);
	}
	if (file_names->placeFile == NULL) {
		file_names->placeFile = (char *) malloc(sizeof(char) * (len + 7)); /*"circuitname.place\0"*/
		sprintf(file_names->placeFile, "%s.place", file_names->circuitName);
	}
	if (file_names->routeFile == NULL) {
		file_names->routeFile = (char *) malloc(sizeof(char) * (len + 7)); /*"circuitname.route\0"*/
		sprintf(file_names->routeFile, "%s.route", file_names->circuitName);
	}

}

static void print_usage() {
	puts(
			"Usage:  hpower fpga_architecture.xml circuit_name power_lib.xml\n"
					"\t--crit_path CriticalPathTime --chan_width ChannelWidth [Options ...]");
	puts("");
	puts(
			"General Options:[--act_file <string>][--blif_file <string>][--net_file <string>][--place_file <string>][--route_file <string>]");
	puts("");
}

/* This is a modification of the init_arch function to use Arch as param.
 * Sets globals: nx, ny
 * Allocs globals: chan_width_x, chan_width_y, grid
 * Depends on num_clbs, pins_per_clb */
static void InitArch(t_arch Arch) {
	int *num_instances_type, *num_blocks_type;
	int i;
	int current, high, low;
	boolean fit;

	current = nint(sqrt(num_blocks)); /* current is the value of the smaller side of the FPGA */
	low = 1;
	high = -1;

	num_instances_type = my_calloc(num_types, sizeof(int));
	num_blocks_type = my_calloc(num_types, sizeof(int));

	for (i = 0; i < num_blocks; i++) {
		num_blocks_type[block[i].type->index]++;
	}

	if (Arch.clb_grid.IsAuto) {
		/* Auto-size FPGA, perform a binary search */
		while (high == -1 || low < high) {
			/* Generate grid */
			if (Arch.clb_grid.Aspect >= 1.0) {
				ny = current;
				nx = nint(current * Arch.clb_grid.Aspect);
			} else {
				nx = current;
				ny = nint(current / Arch.clb_grid.Aspect);
			}
#if DEBUG
			printf("Auto-sizing FPGA, try x = %d y = %d\n", nx, ny);
#endif
			alloc_and_load_grid(num_instances_type);
			freeGrid();

			/* Test if netlist fits in grid */
			fit = TRUE;
			for (i = 0; i < num_types; i++) {
				if (num_blocks_type[i] > num_instances_type[i]) {
					fit = FALSE;
					break;
				}
			}

			/* get next value */
			if (!fit) {
				/* increase size of max */
				if (high == -1) {
					current = current * 2;
					if (current > MAX_SHORT) {
						printf(
								ERRTAG
								"FPGA required is too large for current architecture settings\n");
						exit(1);
					}
				} else {
					if (low == current)
						current++;
					low = current;
					current = low + ((high - low) / 2);
				}
			} else {
				high = current;
				current = low + ((high - low) / 2);
			}
		}
		/* Generate grid */
		if (Arch.clb_grid.Aspect >= 1.0) {
			ny = current;
			nx = nint(current * Arch.clb_grid.Aspect);
		} else {
			nx = current;
			ny = nint(current / Arch.clb_grid.Aspect);
		}
		alloc_and_load_grid(num_instances_type);
		printf("FPGA auto-sized to, x = %d y = %d\n", nx, ny);
	} else {
		nx = Arch.clb_grid.W;
		ny = Arch.clb_grid.H;
		alloc_and_load_grid(num_instances_type);
	}

	printf("The circuit will be mapped into a %d x %d array of clbs.\n", nx,
			ny);

	/* Test if netlist fits in grid */
	fit = TRUE;
	for (i = 0; i < num_types; i++) {
		if (num_blocks_type[i] > num_instances_type[i]) {
			fit = FALSE;
			break;
		}
	}
	if (!fit) {
		printf(ERRTAG "Not enough physical locations for type %s, "
		"number of blocks is %d but number of locations is %d\n",
				type_descriptors[i].name, num_blocks_type[i],
				num_instances_type[i]);
		exit(1);
	}

	printf("\nResource Usage:\n");
	for (i = 0; i < num_types; i++) {
		printf("Netlist      %d\tblocks of type %s\n", num_blocks_type[i],
				type_descriptors[i].name);
		printf("Architecture %d\tblocks of type %s\n", num_instances_type[i],
				type_descriptors[i].name);
	}
	printf("\n");
	chan_width_x = (int *) my_malloc((ny + 1) * sizeof(int));
	chan_width_y = (int *) my_malloc((nx + 1) * sizeof(int));

	free(num_blocks_type);
	free(num_instances_type);
}
